/ *
 Copyright (C) Federico Zivolo 2017
 Distribuído sob a Licença MIT (os termos da licença estão em http://opensource.org/licenses/MIT).
* / ( função ( e , t ) { 'objeto' == tipo de  exportações && 'indefinido' ! = tipo de  módulo ? módulo . exportações = t ( ) : 'função' == tipo de  definir && definir . amd ? define ( t ) : e . Popper = t ( ) } ) ( este ,function ( ) { 'usar estrito' ; função  e ( e ) { return  e && '[função do objeto]' === { } . toString . chamar ( e ) } função  t ( e , t ) { if ( 1 ! == e . nodeType ) return [ ] ; var  o = getComputedStyle ( e ,null ) ; return  t ? o [ t ] : o } função  o ( e ) { return 'HTML' === e . nodeName ? e : e . parentNode || e . host } função  n ( e ) { if ( ! e ) documento de retorno  . corpo ; interruptor ( e .nodeName ) { case 'HTML' : case 'BODY' : return  e . ownerDocument . corpo ; case '#document' : return  e . corpo ; } var  i = t ( e ) , r = i . estouro , p = i . overflowX , s = i . overflowY ; return  / (auto | rolar ) / . teste ( r + s + p ) ? e : n ( o ( e ) ) } função  r ( e ) { var  o = e && e . offsetParent , i = o && o . nodeName ; return  i && 'BODY' ! == i && 'HTML' ! ==eu ? - 1 ! == [ 'TD' , 'TABLE' ] . indexOf ( o . nodeName ) && 'static' === t ( o , 'position' ) ? r ( o ) : o : e ? e . ownerDocument . documentElement : documento . documentElement } função  p ( e ) { var  t= e . nodeName ; return 'BODY' ! == t && ( 'HTML' === t || r ( e . firstElementChild ) === e ) } função  s ( e ) { return  null === e . parentNode ? e : s ( e . parentNode ) } função  d ( e , t ) {if ( ! e || ! e . nodeType || ! t || ! t . nodeType ) documento de retorno  . documentElement ; var o = e . compareDocumentPosition ( t ) & Node . DOCUMENT_POSITION_FOLLOWING , i = o ? e : t , n = o ? t : e , a = documento . createRange ( ) ; a . setStart ( i , 0 ) , a . setEnd ( n , 0 ) ; var  l = a . commonAncestorContainer ; if ( e ! == l && t ! == l || i . contém ( n ) ) return  p ( l ) ? eu: r ( l ) ; var  f = s ( e ) ; retorno  f . hospedeiro ? d ( f . host , t ) : d ( e , s ( t ) . host ) } função  a ( e ) { var  t = 1 < argumentos . comprimento && void  0 ! ==argumentos [ 1 ] ? argumentos [ 1 ] : 'top' , o = 'top' === t ? 'scrollTop' : 'scrollLeft' , i = e . nodeName ; if ( 'CORPO' === i || 'HTML' === i ) { var  n = e . ownerDocument . documentElement , r = e . ownerDocument. scrollingElement || n ; return  r [ o ] } return  e [ o ] } função  l ( e , t ) { var  o = 2 < argumentos . comprimento && void  0 ! == argumentos [ 2 ] && argumentos [ 2 ] , i = a ( t , 'topo' ) ,n = a ( t , 'esquerda' ) , r = o ? - 1 : 1 ; return  e . topo + = i * r , e . inferior + = i * r , e . esquerda + = n * r , e . direita + = n * r , e } função  f ( e ,t ) { var  o = 'x' === t ? 'Left' : 'Top' , i = 'Left' == o ? 'Right' : 'Bottom' ; retornar  parseFloat ( e [ 'borda' + o + 'Largura' ] , 10 ) + parseFloat ( e [ 'borda' + i + 'Largura' ] , m ( e , t , o , i ) { return  J ( t [ 'deslocamento' + e ] , t [ 'rolar' + e ] , o [ 'cliente' + e ] , o [ 'deslocamento' + e ] , o [ 'rolar' + e ] , ie ( ) ? o [ 'deslocamento' + e] + i [ 'margem' + ( 'Altura' === e ? 'Superior' : 'Esquerda' ) ] + i [ 'margem' + ( 'Altura' === e ? 'Inferior' : 'Direita' ) ] : 0 ) } função  h ( ) { var  e = documento . corpo , t = documento . documentElement , o= ie ( ) && getComputedStyle ( t ) ; return { height : m ( 'Height' , e , t , o ) , width : m ( 'Width' , e , t , o ) } } function  c ( e ) { return  se ( { } , e , { right : e. esquerda + e . largura , parte inferior : e . top + e . altura } ) } função  g ( e ) { var  o = { } ; if ( ie ( ) ) tente { o = e . getBoundingClientRect ( ) ; var  i = a ( e , 'topo' ) ,n = a ( e , 'esquerda' ) ; o . topo + = i , o . esquerda + = n , o . inferior + = i , o . direita + = n } catch ( e ) { } else  o = e . getBoundingClientRect ( ) ; var  r = { esquerda : o . esquerda, topo : o . topo , largura : o . certo - o . esquerda , altura : o . inferior - o . topo } , p = 'HTML' === e . nodeName ? h ( ) : { } , s = p . largura || e . clientWidth || r . certo -r.left,d=p.height||e.clientHeight||r.bottom-r.top,l=e.offsetWidth-s,m=e.offsetHeight-d;if(l||m){var g=t(e);l-=f(g,'x'),m-=f(g,'y'),r.width-=l,r.height-=m}return c(r)}function u(e,o){var i=ie(),r='HTML'===o.nodeName,p=g( e ) , s = g ( o ) , d = n ( e ) , a = t ( o ) , f = parseFloat ( a . borderTopWidth , 10 ) , m = parseFloat ( a . borderLeftWidth , 10 ) , h = c ( { topo : p . topo- s . topo - f , esquerda : p . esquerda - s . esquerda - m , largura : p . largura , altura : p . altura } ) ; se ( h . marginTop = 0 , h . marginLeft = 0 , ! i && r ) { var  u = parseFloat(a.marginTop,10),b=parseFloat(a.marginLeft,10);h.top-=f-u,h.bottom-=f-u,h.left-=m-b,h.right-=m-b,h.marginTop=u,h . marginLeft = b } return ( i ? o . contains ( d ) : o === d && 'BODY' ! == d . nodeName ) && ( h = l ( h , o ) ) , h } função  b ( e ) { var  t = e . ownerDocument . documentElement ,o=u(e,t),i=J(t.clientWidth,window.innerWidth||0),n=J(t.clientHeight,window.innerHeight||0),r=a(t),p=a(t,'left'),s={ topo : r - o . top + o . marginTop , esquerda : p - o . esquerda + o . marginLeft , largura : i , altura : n } ; return  c ( s ) } função  w ( e ) { var  i = e . nodeName ; return 'BODY' ===eu || 'HTML' === i ?! 1 : 'fixo' === t ( e , 'posição' ) || w ( o ( e ) ) } função  y ( e , t , i , r ) { var  p = { topo : 0 , esquerda : 0 } , s = d ( e , t ); if ( 'viewport' === r ) p = b ( s ) ; else { var  a ; 'scrollParent' === r ? ( a = n ( o ( t ) ) , 'BODY' === a . nodeName && ( a = e . ownerDocument . documentElement ) ) : 'window' === r ?a = e . ownerDocument . documentElement : a = r ; var  l = u ( a , s ) ; if ( 'HTML' === a . nodeName && ! w ( s ) ) { var  f = h ( ) , m = f . altura , c = f . largura ; p.top+=l.top-l.marginTop,p.bottom=m+l.top,p.left+=l.left-l.marginLeft,p.right=c+l.left}else p=l}return p.left+=i,p.topo + = i , p . direita - = i , p . inferior - = i , p } função  E ( e ) { var  t = e . largura , o = e . altura ; retornar  t * o } função  v ( e , t , o , i , n ) { var  r= 5 < argumentos . comprimento && void  0 ! == argumentos [ 5 ] ? argumentos [ 5 ] : 0 ; if ( - 1 === e . indexOf ( 'auto' ) ) return  e ; var  p = y ( o , i , r , n ) , s = { topo : {largura : p . largura , altura : t . topo - p . topo } , direita : { largura : p . direito - t . direita , altura : p . altura } , parte inferior : { largura : p . largura , altura : p . inferior - t . inferior }, esquerda : { largura : t . esquerda - p . esquerda , altura : p . altura } } , d = objeto . chaves ( s ) . map ( função ( e ) { return  se ( { key : e } , s [ e ] , { area : E (s [ e ] ) } ) } ) . sort ( função ( e , t ) { return  t . area - e . area } ) , a = d . filtro ( função ( e ) { var  t = e . largura , i = e . altura ; retorno  t > =o . clientWidth && i > = o . clientHeight } ) , l = 0 < a . comprimento ? a [ 0 ] . chave : d [ 0 ] . chave , f = e . dividir ( '-' ) [ 1 ] ; retornar  l + ( f ? '-' + f : '' )}function O(e,t,o){var i=d(t,o);return u(o,i)}function L(e){var t=getComputedStyle(e),o=parseFloat(t.marginTop)+parseFloat(t.marginBottom ) , i = parseFloat ( t . marginLeft ) + parseFloat ( t . marginRight ) , n = { largura : e . offsetWidth + i , height : e . offsetHeight + o } ; retornar  n } função  x ( e ) { var  t = { esquerda :'direita' , direita : 'esquerda' , inferior : 'superior' , superior : 'inferior' } ; return  e . substituir ( / esquerda | direita | baixo | topo / g , função ( e ) { retornar  t [ e ] } ) } função  S ( e , t , o ) { o = o .dividir ( '-' ) [ 0 ] ; var  i = L ( e ) , n = { largura : i . largura , altura : i . altura } , r = - 1 ! == [ 'direita' , 'esquerda' ] . indexOf ( o ) , p = r ? 'topo' : 'esquerda' , s= r ? 'esquerda' : 'topo' , d = r ? 'altura' : 'largura' , a = r ? 'largura' : 'altura' ; retornar  n [ p ] = t [ p ] + t [ d ] / 2 - i [ d ] / 2 , n [ s ] = o === s ? t[ s ] - i [ a ] : t [ x ( s ) ] , n } função  T ( e , t ) { return  Array . protótipo . encontrar ? e . find ( t ) : e . filtro ( t ) [ 0 ] } função  D ( e , t ,o){if(Array.prototype.findIndex)return e.findIndex(function(e){return e[t]===o});var i=T(e,function(e){return e[t]===o});return e.indexOf ( i ) } função  C ( t , o , i ) { var  n = void  0 === i ? t : t . fatia ( 0 , D ( t , 'nome' , i ) ) ; return  n . forEach ( função ( t ) { t [ 'função' ] &&console.warn('`modifier.function` is deprecated, use `modifier.fn`!');var i=t['function']||t.fn;t.enabled&&e(i)&&(o.offsets.popper=c(o.offsets.popper),o.offsets.reference=c(o . offsets . referência ) , o = i ( o , t ) ) } ) , o } função  N ( ) { if ( ! this . state . isDestroyed ) { var  e = { instance : this , styles : { } , arrowStyles : { } , atributos :{ } , Capotou : 1 , deslocamentos : { } } ; e . offsets . referência = O ( este . estado , este . popper , este . referência ) , e . colocação = v ( isto . opções . colocação , e . deslocamentos . referência , isto .popper,this.reference,this.options.modifiers.flip.boundariesElement,this.options.modifiers.flip.padding),e.originalPlacement=e.placement,e.offsets.popper=S(this.popper,e.offsets.referência , e . colocação ) , e . offsets . popper . posição = 'absoluto' , e = C ( este . modificadores , e ) , este . estado . isCreated ? isso . opções . onUpdate ( e ) : ( this . state . isCreated = ! 0 , this.options.onCreate(e))}}function k(e,t){return e.some(function(e){var o=e.name,i=e.enabled;return i&&o===t})}function W(e){para ( var  t = [ ! 1 , 'ms' , 'Webkit' , 'Moz' , 'O' ] , o = e . charAt ( 0 ) . toUpperCase ( ) + e . slice ( 1 ) , n = 0 ; n < t . comprimento - 1 ; n ++ ) { var  i = t[ n ] , r = i ? '' + i + o : e ; if ( 'undefined' ! = typeof  document . body . style [ r ] ) return  r } return  null } function  P ( ) { return  this . estado . isDestroyed = ! 0 , k ( isto .modifiers,'applyStyle')&&(this.popper.removeAttribute('x-placement'),this.popper.style.left='',this.popper.style.position='',this.popper.style.top='',this.popper.style[W('transformar' ) ] = '' ) , isso . disableEventListeners ( ) , isso . opções . removeOnDestroy && this . popper . parentNode . removeChild ( este . popper ) , este } função  B ( e ) { var  t = e . ownerDocument ; return  t ? t .visualização padrão : janela } função  H ( e , t , o , i ) { var  r = 'CORPO' === e . nodeName , p = r ? e . ownerDocument . defaultView : e ; p . addEventListener ( t , o , { passiva : 0 } ) , r || H( n ( p . parentNode ) , t , o , i ) , i . empurre ( p ) } função  A ( e , t , o , i ) { o . updateBound = i , B ( e ) . addEventListener ( 'redimensionamento' , o . updateBound , { passiva :0 } ) ; var  r = n ( e ) ; return  H ( r , 'scroll' , o . updateBound , o . scrollParents ) , o . scrollElement = r , o . eventsEnabled = ! 0 , o } função  I ( ) { this . estado . eventsEnabled || (this.state=A(this.reference,this.options,this.state,this.scheduleUpdate))}function M(e,t){return B(e).removeEventListener('resize',t.updateBound),t.scrollParents.forEach(função ( e ) { e . removeEventListener ( 'scroll' , t . updateBound ) } ) , t . updateBound = null , t . scrollParents = [ ] , t . scrollElement = null , t . eventsEnabled = ! 1 , t } função  R ( ) { isso .estado . eventsEnabled && ( cancelAnimationFrame ( this . scheduleUpdate ) , this . state = M ( this . reference , this . state ) ) } function  U ( e ) { return '' ! == e && ! isNaN ( parseFloat ( e ) ) && isFinite ( e ) }função  Y ( e , t ) { Objeto . chaves ( t ) . forEach ( function ( o ) { var  i = '' ; - 1 ! == [ 'largura' , 'altura' , 'superior' , 'direita' , 'inferior' , 'esquerda' ] . indexOf ( o ) && U ( t [ o ] )&& ( i = 'px' ) , e . estilo [ o ] = t [ o ] + i } ) } função  j ( e , t ) { Objeto . chaves ( t ) . forEach ( função ( o ) { var  i = t [ o ] ; ! 1 === i ?e . removeAttribute ( o ) : e . setAttribute ( o , t [ o ] ) } ) } função  F ( e , t , o ) { var  i = T ( e , função ( e ) { var  o = e . nome ; return  o === t } ) ,n = !! i && e . some ( função ( e ) { return  e . name === o && e . enabled && e . order < i . order } ) ; if ( ! n ) { var  r = '`' + t + '`' ; console . warn ( '`' + o+ O modificador '`' + 'é necessário pelo modificador' + r + 'para funcionar, certifique-se de incluí-lo antes de' + r + '!' ) } return  n } função  K ( e ) { return 'end' === e ? 'start' : 'start' === e ? 'fim' : e } função  q ( e ) { var  t = 1 <comprimento && void  0 ! == argumentos [ 1 ] && argumentos [ 1 ] , o = ae . indexOf ( e ) , i = ae . fatia ( o + 1 ) . concat ( ae . slice ( 0 , o ) ) ; return  t ? eu . reverso ( ) : i}function V(e,t,o,i){var n=e.match(/((?:\-|\+)?\d*\.?\d*)(.*)/),r=+n[1],p=n[2];if(! r ) retorno  e ; if ( 0 === p . indexOf ( '%' ) ) { var  s ; switch ( p ) { case '% p' : s = o ; pausa ; case '%' : case '% r' : default : s = i ; } var  d = c ( s ) ; Retorna d [ t ] / 100 * r } if ( 'vh' === p || 'vw' === p ) { var  a ; return  a = 'vh' === p ? J ( document . DocumentElement . ClientHeight , window . InnerHeight || 0 ) : J ( document . DocumentElement . ClientWidth ,janela . innerWidth || 0 ) , a / 100 * r } retorno  r } função  z ( e , t , o , i ) { var  n = [ 0 , 0 ] , r = - 1 ! == [ 'direita' , 'esquerda' ] . indexOf ( i ) , p = e .dividir ( / ( \ + | \ - ) / ) . map ( função ( e ) { return  e . trim ( ) } ) , s = p . indexOf ( T ( p , function ( e ) { return - 1 ! == e . search ( /, | \ s / ) } )) ; p [ s ] && - 1 === p [ s ] . indexOf ( ',' ) && console . warn ( 'Offsets separados por espaço (s) em branco estão obsoletos, use uma vírgula (,) ao invés.' ) ; var  d = / \ s * , \ s * | \ s + / , a = - 1 === s ? [ p ] : [p.slice(0,s).concat([p[s].split(d)[0]]),[p[s].split(d)[1]].concat(p.slice(s+1))];return a=a. map ( função ( e , i ) { var  n = ( 1 === i ?! r : r ) ? 'altura' : 'largura' , p = ! 1 ; retornar  e . reduzir ( função ( e , t ) { return '' === e [ e . comprimento - 1 ] && -1 ! == [ '+' , '-' ] . indexOf ( t ) ? ( e [ comprimento de e . - 1 ] = t , p = ! 0 , e ) : p ? ( e [ comprimento de e . - 1 ] + = t , p = ! 1 , e ) : e . concat (t)},[]).map(function(e){return V(e,n,t,o)})}),a.forEach(function(e,t){e.forEach(function(o,i){U(o)&&( n [ t ] + = o * ( '-' === e [ i - 1 ] ? - 1 : 1 ) ) } ) } ) , n } função  G ( e , t ) { var  o , i = t . deslocamento , n = e . colocação , r = e . compensações, p = r . popper , s = r . referência , d = n . dividir ( '-' ) [ 0 ] ; retornar  o = U ( + i ) ? [ + i , 0 ] : z ( i , p , s , d ) , 'esquerda' === d ? ( p .topo + = o [ 0 ] , p . esquerda - = o [ 1 ] ) : 'direita' === d ? ( p . superior + = o [ 0 ] , p . esquerda + = o [ 1 ] ) : 'superior' === d ? ( p . esquerda + = o [ 0 ] , p . topo- = o [ 1 ] ) : 'inferior' === d && ( p . esquerda + = o [ 0 ] , p . superior + = o [ 1 ] ) , e . popper = p , e } para ( var  _ = Math . min , X = Math . floor , J = Math .max , Q = 'undefined' ! = typeof  janela && 'undefined' ! = typeof  document , Z = [ 'Edge' , 'Trident' , 'Firefox' ] , $ = 0 , ee = 0 ; ee < Z . comprimento ; ee + = 1 ) if ( Q && 0 <= navegador . userAgent . indexOf (Z [ ee ] ) ) { $ = 1 ; break } var  i , te = janela Q && . Promessa , oe = te ? função ( e ) { var t = ! 1 ; função de retorno ( ) { t || ( t = ! 0 , janela . Promessa . resolver  ( ) . então ( função ( ) { t = ! 1 , e ( ) } ) ) } } : função ( e ) { var  t = ! 1 ; função de retorno  ( ) { t || ( t = ! 0 , setTimeout ( function ( ) { t = ! 1 ,e ( ) } , $ ) ) } } , ou seja , = function ( ) { return  void  0 == i && ( i = - 1 ! == navigator . appVersion . indexOf ( 'MSIE 10' ) ) , i } , ne = função ( e , t ) { if ( ! ( e instanceof t))throw new TypeError('Cannot call a class as a function')},re=function(){function e(e,t){for(var o,n=0;n<t.length;n++)o=t[n],o.enumerable= o . enumerável || ! 1 , o . configurável = ! 0 , 'valor' em  o && ( o . Gravável = ! 0 ) , Objeto . defineProperty ( e , o . tecla , o ) } função de retorno  ( t , o , i ) { return o && e ( t . protótipo , o ) , i && e ( t , i ) , t } } ( ) , pe = função ( e , t , o ) { retornar  t  em  e ? Objeto . defineProperty ( e , t , { valor : o , enumeráveis : 0 , configurável:! 0 , gravável : 0 } ) : e [ t ] = o , e } , se = Objeto . atribuir || função ( e ) { para ( var  t , o = 1 ; o < argumentos . comprimento ; o ++ ) para ( var  i  em  t = argumentos [o],t)Object.prototype.hasOwnProperty.call(t,i)&&(e[i]=t[i]);return e},de=['auto-start','auto','auto-end','top-start','top','top-end','right-start','right','extremidade direita' , 'extremidade inferior' , 'inferior' , 'início inferior' , 'extremidade esquerda' , 'esquerda' , 'início à esquerda' ] , ae = de . fatia ( 3 ) , le = { FLIP : 'flip' , HORÁRIO : 'sentido horário' , ANTI - HORÁRIO : 'anti-horário' } , i ) { var  n = this , r = 2 < argumentos . comprimento && void  0 ! == argumentos [ 2 ] ? argumentos [ 2 ] : { } ; ne ( isso , t ) , isso . ScheduleUpdate = function ( ) { return  requestAnimationFrame ( n . update )} , isso . update = oe ( this . update . bind ( this ) ) , this . options = se ( { } , t . Padrões , r ) , isso . estado = { isDestroyed : 1 , iscreated : 1 , scrollParents : [ ] } , este .referência = o && o . jquery ? o [ 0 ] : o , isso . popper = i && i . jquery ? i [ 0 ] : i , este . opções . modificadores = { } , objeto . chaves ( se ( { } , t . Padrões . modificadores ,r.modifiers)).forEach(function(e){n.options.modifiers[e]=se({},t.Defaults.modifiers[e]||{},r.modifiers?r.modifiers[e]:{})}),isso . modificadores = objeto . chaves ( este . opções . modificadores ) . map ( função ( e ) { return  se ( { nome : e } , n . opções . modificadores [ e ] ) } ) . sort ( função ( e , t ) { return  e .order-t.order}),this.modifiers.forEach(function(t){t.enabled&&e(t.onLoad)&&t.onLoad(n.reference,n.popper,n.options,t,n.state)}),this. update ( ) ; var  p = isso . opções . eventsEnabled ; p && isso . enableEventListeners ( ) , isso . estado . eventsEnabled = p } return  re ( t , [ { key : 'update' , valor : função ( ) { retornar  N . chamada ( esta) } } , { Chave : 'destruir' , valor : função ( ) { return  P . chamar ( este ) } } , { -chave : 'enableEventListeners' , valor : função ( ) { retornar  I . call ( this ) } } , { key : 'disableEventListeners' , value :função ( ) { return  R . chamar ( este ) } } ] ) , t } ( ) ; return  fe . Utils = ( 'undefined' == typeof  window ? Global : window ) . PopperUtils , fe . colocações = de , fe . Padrões = { posicionamento : 'inferior' ,eventsEnabled:!0,removeOnDestroy:!1,onCreate:function(){},onUpdate:function(){},modifiers:{shift:{order:100,enabled:!0,fn:function(e){var t=e.placement,o=t . split ( '-' ) [ 0 ] , i = t . dividir ( '-' ) [ 1 ] ; if ( i ) { var  n = e . deslocamentos , r = n . referência , p = n . popper , s = - 1 ! == [ 'inferior' , 'superior' ] .indexOf(o),d=s?'left':'top',a=s?'width':'height',l={start:pe({},d,r[d]),end:pe({},d,r[d]+r[a]-p [ a ] ) } ; e . offsets . popper = se ( { } , p , l [ i ] ) } return  e } } , deslocamento : { pedido : 200 , habilitado :! 0 , fn : G , deslocamento : 0 } , preventOverflow : { pedido : 300, ativado :! 0 , fn : função ( e , t ) { var  o = t . boundariesElement || r ( e . instância . Popper ) ; e . instância . referência === o && ( o = r ( o ) ) ; var  i = y ( e . instância .popper , e . instância . referência , t . enchimento , o ) ; t . limites = i ; var  n = t . prioridade , p = e . offsets . popper , s = { primário : função ( e ) { var  o = p [ e ] ; voltar  p[ e ] < i [ e ] && ! t . escapeWithReference && ( o = J ( p [ e ] , i [ e ] ) ) , pe ( { } , e , o ) } , secundário : função ( e ) { var  o = 'direito' === e ? 'esquerda': 'superior' , n = p [ o ] ; return  p [ e ] > i [ e ] && ! t . escapeWithReference && ( n = _ ( p [ o ] , i [ e ] - ( 'direito' === e ? p . largura : p . altura ) ) ) , pe( { } , o , n ) } } ; return  n . forEach ( function ( e ) { var  t = - 1 === [ 'left' , 'top' ] . indexOf ( e ) ? 'secundário' : 'primário' ; p = se ( { } , p , s [ t ] ( e))}),e.offsets.popper=p,e},priority:['left','right','top','bottom'],padding:5,boundariesElement:'scrollParent'},keepTogether:{order:400,enabled:!0,fn:function(e){var t=e.offsets,o=t.popper,i=t.reference,n=e.placement.split('-')[0],r=X,p=-1!==['top','bottom'].indexOf(n),s=p?'right':'bottom',d=p?'left':'top',a=p?'width':'height';return o[s]<r(i[d])&&(e.offsets.popper[d]=r(i[d])-o[a]),o[d]>r(i[s])&&(e.offsets.popper[d]=r(i[s])),e}},arrow:{order:500,enabled:!0,fn:function(e,o){var i;if(!F(e.instance.modifiers,'arrow','keepTogether'))return e;var n=o.element;if('string'==typeof n){if(n=e.instance.popper.querySelector(n),!n)return e;}else if(!e.instance.popper.contains(n))return console.warn('WARNING: `arrow.element` must be child of its popper element!'),e;var r=e.placement.split('-')[0],p=e.offsets,s=p.popper,d=p.reference,a=-1!==['left','right'].indexOf(r),l=a?'height':'width',f=a?'Top':'Left',m=f.toLowerCase(),h=a?'left':'top',g=a?'bottom':'right',u=L(n)[l];d[g]-u<s[m]&&(e.offsets.popper[m]-=s[m]-(d[g]-u)),d[m]+u>s[g]&&(e.offsets.popper[m]+=d[m]+u-s[g]),e.offsets.popper=c(e.offsets.popper);var b=d[m]+d[l]/2-u/2,w=t(e.instance.popper),y=parseFloat(w['margin'+f],10),E=parseFloat(w['border'+f+'Width'],10),v=b-e.offsets.popper[m]-y-E;return v=J(_(s[l]-u,v),0),e.arrowElement=n,e.offsets.arrow=(i={},pe(i,m,Math.round(v)),pe(i,h,''),i),e},element:'[x-arrow]'},flip:{order:600,enabled:!0,fn:function(e,t){if(k(e.instance.modifiers,'inner'))return e;if(e.flipped&&e.placement===e.originalPlacement)return e;var o=y(e.instance.popper,e.instance.reference,t.padding,t.boundariesElement),i=e.placement.split('-')[0],n=x(i),r=e.placement.split('-')[1]||'',p=[];switch(t.behavior){case le.FLIP:p=[i,n];break;case le.CLOCKWISE:p=q(i);break;case le.COUNTERCLOCKWISE:p=q(i,!0);break;default:p=t.behavior;}return p.forEach(function(s,d){if(i!==s||p.length===d+1)return e;i=e.placement.split('-')[0],n=x(i);var a=e.offsets.popper,l=e.offsets.reference,f=X,m='left'===i&&f(a.right)>f(l.left)||'right'===i&&f(a.left)<f(l.right)||'top'===i&&f(a.bottom)>f(l.top)||'bottom'===i&&f(a.top)<f(l.bottom),h=f(a.left)<f(o.left),c=f(a.right)>f(o.right),g=f(a.top)<f(o.top),u=f(a.bottom)>f(o.bottom),b='left'===i&&h||'right'===i&&c||'top'===i&&g||'bottom'===i&&u,w=-1!==['top','bottom'].indexOf(i),y=!!t.flipVariations&&(w&&'start'===r&&h||w&&'end'===r&&c||!w&&'start'===r&&g||!w&&'end'===r&&u);(m||b||y)&&(e.flipped=!0,(m||b)&&(i=p[d+1]),y&&(r=K(r)),e.placement=i+(r?'-'+r:''),e.offsets.popper=se({},e.offsets.popper,S(e.instance.popper,e.offsets.reference,e.placement)),e=C(e.instance.modifiers,e,'flip'))}),e},behavior:'flip',padding:5,boundariesElement:'viewport'},inner:{order:700,enabled:!1,fn:function(e){var t=e.placement,o=t.split('-')[0],i=e.offsets,n=i.popper,r=i.reference,p=-1!==['left','right'].indexOf(o),s=-1===['top','left'].indexOf(o);return n[p?'left':'top']=r[o]-(s?n[p?'width':'height']:0),e.placement=x(t),e.offsets.popper=c(n),e}},hide:{order:800,enabled:!0,fn:function(e){if(!F(e.instance.modifiers,'hide','preventOverflow'))return e;var t=e.offsets.reference,o=T(e.instance.modifiers,function(e){return'preventOverflow'===e.name}).boundaries;if(t.bottom<o.top||t.left>o.right||t.top>o.bottom||t.right<o.left){if(!0===e.hide)return e;e.hide=!0,e.attributes['x-out-of-boundaries']=''}else{if(!1===e.hide)return e;e.hide=!1,e.attributes['x-out-of-boundaries']=!1}return e}},computeStyle:{order:850,enabled:!0,fn:function(e,t){var o=t.x,i=t.y,n=e.offsets.popper,p=T(e.instance.modifiers,function(e){return'applyStyle'===e.name}).gpuAcceleration;void 0!==p&&console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');var s,d,a=void 0===p?t.gpuAcceleration:p,l=r(e.instance.popper),f=g(l),m={position:n.position},h={left:X(n.left),top:X(n.top),bottom:X(n.bottom),right:X(n.right)},c='bottom'===o?'top':'bottom',u='right'===i?'left':'right',b=W('transform');if(d='bottom'==c?-f.height+h.bottom:h.top,s='right'==u?-f.width+h.right:h.left,a&&b)m[b]='translate3d('+s+'px, '+d+'px, 0)',m[c]=0,m[u]=0,m.willChange='transform';else{var w='bottom'==c?-1:1,y='right'==u?-1:1;m[c]=d*w,m[u]=s*y,m.willChange=c+', '+u}var E={"x-placement":e.placement};return e.attributes=se({},E,e.attributes),e.styles=se({},m,e.styles),e.arrowStyles=se({},e.offsets.arrow,e.arrowStyles),e},gpuAcceleration:!0,x:'bottom',y:'right'},applyStyle:{order:900,enabled:!0,fn:function(e){return Y(e.instance.popper,e.styles),j(e.instance.popper,e.attributes),e.arrowElement&&Object.keys(e.arrowStyles).length&&Y(e.arrowElement,e.arrowStyles),e},onLoad:function(e,t,o,i,n){var r=O(n,t,e),p=v(o.placement,r,t,e,o.modifiers.flip.boundariesElement,o.modifiers.flip.padding);return t.setAttribute('x-placement',p),Y(t,{position:'absolute'}),o},gpuAcceleration:void 0}}},fe});
//# sourceMappingURL=popper.min.js.map